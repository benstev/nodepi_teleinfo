// Generated by CoffeeScript 1.7.1
(function() {
  var config, delay, intRes, log, log4js, mqtt, recordSample, resetIntegral, returnStatusCode, sampleCnt, sendIntegral, sending, setStatus, teleinfo, trameEvents, util;

  teleinfo = require('teleinfo');

  util = require('util');

  config = require('./config');

  log4js = require('log4js');

  log = log4js.getLogger();

  log.setLevel(config.logging_level);

  log.info(util.format('logging level [%s]', config.logging_level));

  sending = true;

  intRes = {};

  sampleCnt = 0;

  trameEvents = teleinfo(config.serial_port);

  recordSample = function(data) {
    var f, field, _ref;
    _ref = config.teleinfo.summary_fields;
    for (field in _ref) {
      f = _ref[field];
      if (f.func === 'avg') {
        intRes[field] = intRes[field] + data[field];
      } else if (f.func === 'max') {
        intRes[field] = Math.max(intRes[field], data[field]);
      }
    }
    return sampleCnt += 1;
  };

  trameEvents.on('tramedecodee', function(data) {
    var field, msg, mstr, _i, _len, _ref;
    if (sending) {
      msg = {};
      _ref = config.teleinfo.fields;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        field = _ref[_i];
        msg[field] = data[field];
      }
      mstr = JSON.stringify(msg);
      log.debug(util.format('publish message <%s> to topic <%s>', mstr, config.teleinfo.topic));
      mqtt.publish(config.teleinfo.topic, mstr);
      return recordSample(data);
    }
  });

  trameEvents.on('error', function(err) {
    return log.warn(util.inspect(err));
  });

  log.info(util.format('Connecting to mqtt <%s:%s>', config.mqtt.host, config.mqtt.port));

  mqtt = require('mqtt').createClient(config.mqtt.port, config.mqtt.host);

  mqtt.on('connect', function() {
    var connected;
    log.info('mqtt connected!');
    return connected = true;
  });

  returnStatusCode = function() {
    if (sending) {
      mqtt.publish(config.teleinfo.status_topic, 'I');
      return log.debug(util.format('publish message <I> to topic <%s>', config.teleinfo.status_topic));
    } else {
      mqtt.publish(config.teleinfo.status_topic, 'O');
      return log.debug(util.format('publish message <O> to topic <%s>', config.teleinfo.status_topic));
    }
  };

  setStatus = function(status) {
    sending = status;
    return returnStatusCode();
  };

  mqtt.on('message', function(topic, message) {
    var cc;
    log.debug(util.format('Mqtt message <%s> received from topic <%s>', message, topic));
    cc = message.toUpperCase();
    switch (cc[0]) {
      case "S":
        return returnStatusCode();
      case "I":
        return setStatus(true);
      case "O":
        return setStatus(false);
      default:
        return go(log.warn('Unknown command code received!'));
    }
  });

  delay = function(time, fn) {
    return setInterval(fn, time);
  };

  resetIntegral = function() {
    var f, field, _ref;
    _ref = config.teleinfo.summary_fields;
    for (field in _ref) {
      f = _ref[field];
      intRes[field] = 0;
    }
    return sampleCnt = 0;
  };

  sendIntegral = function() {
    var astr, f, field, v, _ref;
    if (sending && sampleCnt > 0) {
      _ref = config.teleinfo.summary_fields;
      for (field in _ref) {
        f = _ref[field];
        if (f.func === 'avg') {
          v = intRes[field] / sampleCnt;
        } else {
          v = intRes[field];
        }
        astr = JSON.stringify(v);
        log.debug(util.format('SEND INTEGRAL <%s> to topic <%s>', astr, f.topic));
        mqtt.publish(f.topic, astr);
      }
    }
    return resetIntegral();
  };

  resetIntegral();

  delay(config.teleinfo.integration_seconds * 1000, sendIntegral);

  mqtt.subscribe(config.teleinfo.command_topic);

}).call(this);
